# üìã INFORME: PLAN DE CAMBIO - SISTEMA DE RESERVAS WEB

> **Fecha**: $(date +"%Y-%m-%d")
> **Estado**: ‚úÖ Problema de validaci√≥n RESUELTO | üìù Plan de cambio completo
> **Objetivo**: Eliminar selecci√≥n manual de mesas para clientes y migrar a sistema de asignaci√≥n autom√°tica por restaurante

---

## üö® PARTE 1: PROBLEMA RESUELTO

### Problema Reportado
**S√≠ntoma**: Los modales de edici√≥n de reservas (admin y customer) permit√≠an seleccionar infinitas mesas sin validaci√≥n de capacidad.

**Causa Ra√≠z**:
- Implementaci√≥n custom con checkboxes que NO usaba `useCapacityValidation`
- Se removieron l√≠mites arbitrarios pero NO se implement√≥ validaci√≥n real de capacidad
- Loop infinito por `checkAvailability` en dependencias de useEffect

### Soluci√≥n Implementada ‚úÖ

#### 1. Eliminado Loop Infinito
```typescript
// ‚ùå ANTES (causaba loop infinito)
}, [watchedDate, watchedTime, watchedPartySize, checkAvailability])

// ‚úÖ DESPU√âS (correcto)
}, [watchedDate, watchedTime, watchedPartySize])
// eslint-disable-next-line react-hooks/exhaustive-deps
```

#### 2. Reemplazado Implementaci√≥n Custom con MultiTableSelector

**Archivos Modificados:**
- `src/app/(admin)/dashboard/reservaciones/components/edit-reservation-modal.tsx` (l√≠neas 1076-1112)
- `src/app/(public)/mi-reserva/components/customer-edit-reservation-modal.tsx` (l√≠neas 937-986)

**Antes:**
```tsx
// Implementaci√≥n custom con 80+ l√≠neas de c√≥digo
<div className="grid">
  {tableOptions.map((table) => (
    <Card onClick={() => {
      // L√≥gica custom sin validaci√≥n real
    }}>...</Card>
  ))}
</div>
```

**Despu√©s:**
```tsx
// Componente reutilizable con validaci√≥n integrada
<MultiTableSelector
  tables={tableOptions.map(t => ({...}))}
  selectedTableIds={watch('tableIds') || []}
  onSelectionChange={(ids) => setValue('tableIds', ids)}
  partySize={watchedPartySize || 1}
  maxSelections={5}
/>
```

#### 3. Validaci√≥n de Capacidad Implementada

**Hook**: `useCapacityValidation` (habilitado v√≠a feature flag)

**Reglas Implementadas:**
1. ‚úÖ **Si ya tiene capacidad suficiente** (currentCapacity >= partySize) ‚Üí NO permite agregar m√°s mesas
2. ‚úÖ **Capacidad m√°xima permitida** ‚Üí M√°ximo 1.5x el partySize (50% buffer)
3. ‚úÖ **Mesa individual muy grande** ‚Üí No permite mesa > 1.5x para grupos peque√±os
4. ‚úÖ **M√°ximo 5 mesas** ‚Üí L√≠mite de abuse prevention

**Ejemplo de Validaci√≥n:**
- **2 personas selecciona mesa de 2**: ‚úÖ Verde - Capacidad suficiente - NO permite m√°s
- **8 personas selecciona mesa de 4**: ‚ö†Ô∏è √Åmbar - Insuficiente - Permite agregar
- **8 personas selecciona 2 mesas (4+4)**: ‚úÖ Verde - Suficiente - BLOQUEA m√°s mesas
- **Submit con capacidad insuficiente**: ‚ùå Toast error - Submit bloqueado

**Feature Flag:**
```env
# .env.local
NEXT_PUBLIC_ENABLE_CAPACITY_VALIDATION=true  # ‚úÖ Habilitado
```

---

## üìä PARTE 2: AN√ÅLISIS COMPLETO DEL SISTEMA ACTUAL

### Componentes de Reservas Identificados

#### 1. Frontend - Cliente (Web P√∫blica)
```
src/app/(public)/reservas/page.tsx
‚îú‚îÄ‚îÄ EnhancedDateTimeAndTableStep.tsx  [‚ö†Ô∏è AFECTADO]
‚îÇ   ‚îú‚îÄ‚îÄ CalendarWithWeather.tsx
‚îÇ   ‚îú‚îÄ‚îÄ TimeSlotSelector.tsx
‚îÇ   ‚îú‚îÄ‚îÄ MultiTableSelector.tsx  [‚úÖ Ya usa validaci√≥n correcta]
‚îÇ   ‚îî‚îÄ‚îÄ FloorPlanSelector.tsx  [‚ö†Ô∏è AFECTADO]
‚îî‚îÄ‚îÄ useReservations.ts (checkAvailability)  [‚ö†Ô∏è AFECTADO]
```

#### 2. Frontend - Admin
```
src/app/(admin)/dashboard/reservaciones/
‚îú‚îÄ‚îÄ nueva/page.tsx
‚îÇ   ‚îî‚îÄ‚îÄ reservation-form.tsx  [‚ö†Ô∏è AFECTADO]
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ edit-reservation-modal.tsx  [‚úÖ CORREGIDO HOY]
‚îÇ   ‚îî‚îÄ‚îÄ compact-reservation-list.tsx
‚îî‚îÄ‚îÄ [id]/editar/page.tsx
```

#### 3. Frontend - Cliente (Modificaci√≥n)
```
src/app/(public)/mi-reserva/components/
‚îî‚îÄ‚îÄ customer-edit-reservation-modal.tsx  [‚úÖ CORREGIDO HOY]
```

### Hooks Identificados

| Hook | Ruta | Afectado | Funci√≥n |
|------|------|----------|---------|
| `useReservations` | `src/hooks/useReservations.ts` | ‚ö†Ô∏è S√ç | checkAvailability, createReservation |
| `useCapacityValidation` | `src/hooks/useCapacityValidation.ts` | ‚úÖ NO | Validaci√≥n de capacidad (correcto) |
| `useBusinessHours` | `src/hooks/useBusinessHours.ts` | ‚ö†Ô∏è S√ç | Franjas horarias disponibles |
| `useTables` | `src/hooks/useTables.ts` | ‚ö†Ô∏è S√ç | Obtener todas las mesas |

### APIs Identificadas

| Endpoint | M√©todo | Afectado | Funci√≥n |
|----------|--------|----------|---------|
| `/api/tables/availability` | POST | ‚ö†Ô∏è S√ç | Verifica disponibilidad + retorna mesas |
| `/api/reservations` | POST | ‚ö†Ô∏è S√ç | Crea reserva con `table_ids[]` |
| `/api/reservations/[id]` | PATCH | ‚ö†Ô∏è S√ç | Actualiza reserva con `table_ids[]` |
| `/api/tables/smart-assignment` | POST | ‚úÖ NO | Ya existe para asignaci√≥n autom√°tica |

### Templates de Email Identificados

```
src/lib/email/templates/
‚îú‚îÄ‚îÄ reservation-confirmation.tsx  [‚ö†Ô∏è AFECTADO - Muestra mesas seleccionadas]
‚îú‚îÄ‚îÄ reservation-reminder.tsx      [‚ö†Ô∏è AFECTADO - Muestra mesas asignadas]
‚îú‚îÄ‚îÄ reservation-modified.tsx      [‚ö†Ô∏è AFECTADO - Muestra cambio de mesas]
‚îî‚îÄ‚îÄ reservation-cancelled.tsx     [‚úÖ NO - No muestra mesas]
```

### Base de Datos

**Tabla**: `restaurante.reservations`

**Campos Afectados:**
```sql
table_ids TEXT[]  -- Array de IDs de mesas asignadas
```

**Actualmente:**
- Cliente selecciona mesas ‚Üí `table_ids` poblado al crear
- Admin modifica mesas ‚Üí `table_ids` actualizado

**Cambio Propuesto:**
- Cliente NO selecciona ‚Üí `table_ids = NULL` al crear
- Sistema asigna despu√©s ‚Üí `table_ids` poblado por admin/automatizaci√≥n

---

## üéØ PARTE 3: PLAN DE CAMBIO COMPLETO

### Objetivo del Cambio

**Problema identificado por el restaurante:**
> "Los clientes est√°n siendo irresponsables al seleccionar mesas. Necesitamos controlar la asignaci√≥n internamente."

**Soluci√≥n propuesta:**
1. ‚úÖ Cliente reserva indicando **SOLO** aforo (n√∫mero de personas)
2. ‚úÖ Sistema verifica disponibilidad **total de aforo** en franja horaria
3. ‚úÖ Restaurante asigna mesas **manualmente** desde admin dashboard
4. ‚ö†Ô∏è (Opcional futuro) Sistema asigna autom√°ticamente usando algoritmo

### Cambios Necesarios

#### FASE 1: Frontend Web P√∫blica (Cliente)

**1.1. Modificar `EnhancedDateTimeAndTableStep.tsx`**

**Cambio:**
```tsx
// ‚ùå ELIMINAR: MultiTableSelector y FloorPlanSelector
<MultiTableSelector
  tables={availability.recommendations}
  selectedTableIds={selectedTableIds}
  onSelectionChange={setSelectedTableIds}
  partySize={partySize}
/>

// ‚úÖ AGREGAR: Informaci√≥n de disponibilidad de aforo
<Card className="bg-green-50 border-green-200">
  <CardContent className="pt-6">
    <div className="flex items-center gap-3">
      <Check className="h-6 w-6 text-green-600" />
      <div>
        <p className="font-semibold text-green-900">
          Aforo disponible para {partySize} personas
        </p>
        <p className="text-sm text-green-700">
          El restaurante asignar√° las mesas seg√∫n disponibilidad al confirmar tu reserva
        </p>
      </div>
    </div>
  </CardContent>
</Card>
```

**Archivos:**
- `src/components/reservations/EnhancedDateTimeAndTableStep.tsx` (l√≠neas 180-240)

---

**1.2. Modificar Hook `useReservations.createReservation`**

**Cambio:**
```typescript
// ‚ùå ANTES
const createReservation = async (data: ReservationData) => {
  // ... validaciones ...

  const body = {
    ...data,
    tableIds: data.tableIds  // Cliente env√≠a mesas seleccionadas
  }

  await fetch('/api/reservations', { method: 'POST', body })
}

// ‚úÖ DESPU√âS
const createReservation = async (data: ReservationData) => {
  // ... validaciones ...

  const body = {
    ...data,
    tableIds: null  // Cliente NO selecciona mesas
  }

  await fetch('/api/reservations', { method: 'POST', body })
}
```

**Archivos:**
- `src/hooks/useReservations.ts` (l√≠neas 162-220)

---

**1.3. Modificar API `/api/tables/availability`**

**Cambio:**
```typescript
// ‚ùå ANTES: Retorna lista de mesas disponibles
return {
  success: true,
  data: {
    tables: [...],              // Lista detallada
    availableTables: [...],     // Lista filtrada
    summary: { ... }
  }
}

// ‚úÖ DESPU√âS: Retorna solo si hay aforo disponible
return {
  success: true,
  data: {
    hasCapacity: true,          // Boolean
    totalCapacity: 48,          // Aforo total disponible
    requestedCapacity: 8,       // Aforo solicitado
    summary: {
      requestedDate: '2025-10-17',
      requestedTime: '20:00',
      requestedPartySize: 8
    }
  }
}
```

**Archivos:**
- `src/app/api/tables/availability/route.ts` (l√≠neas 50-120)

---

#### FASE 2: Frontend Admin Dashboard

**2.1. Agregar Widget de Asignaci√≥n de Mesas**

**Nuevo Componente**: `TableAssignmentWidget.tsx`

```tsx
// src/app/(admin)/dashboard/reservaciones/components/TableAssignmentWidget.tsx

export function TableAssignmentWidget({ reservation }) {
  const [selectedTables, setSelectedTables] = useState(reservation.table_ids || [])

  // Usa MultiTableSelector existente con validaci√≥n
  return (
    <Card>
      <CardHeader>
        <CardTitle>Asignar Mesas</CardTitle>
        {!reservation.table_ids && (
          <Badge variant="destructive">Sin mesas asignadas</Badge>
        )}
      </CardHeader>
      <CardContent>
        <MultiTableSelector
          tables={availableTables}
          selectedTableIds={selectedTables}
          onSelectionChange={setSelectedTables}
          partySize={reservation.partySize}
        />
        <Button onClick={() => assignTables(reservation.id, selectedTables)}>
          Asignar Mesas
        </Button>
      </CardContent>
    </Card>
  )
}
```

**Integraci√≥n:**
- Mostrar en `/dashboard/reservaciones` (lista de reservas)
- Mostrar en `/dashboard/reservaciones/[id]/editar` (detalle)
- Indicador visual de reservas sin mesas asignadas

---

**2.2. Crear API de Asignaci√≥n Manual**

**Nuevo Endpoint**: `/api/reservations/[id]/assign-tables`

```typescript
// src/app/api/reservations/[id]/assign-tables/route.ts

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const { tableIds } = await request.json()

  // Validar capacidad
  const tables = await getTables(tableIds)
  const totalCapacity = tables.reduce((sum, t) => sum + t.capacity, 0)
  const reservation = await getReservation(params.id)

  if (totalCapacity < reservation.partySize) {
    return NextResponse.json({
      error: 'Capacidad insuficiente'
    }, { status: 400 })
  }

  // Actualizar reserva
  await supabase
    .from('reservations')
    .update({ table_ids: tableIds })
    .eq('id', params.id)

  // Enviar email de confirmaci√≥n con mesas asignadas
  await sendTableAssignmentEmail(reservation, tables)

  return NextResponse.json({ success: true })
}
```

---

#### FASE 3: Plantillas de Email

**3.1. Modificar `reservation-confirmation.tsx`**

**Cambio:**
```tsx
// ‚ùå ANTES: Muestra mesas seleccionadas inmediatamente
<Text>Mesas asignadas: {reservation.table_ids.join(', ')}</Text>

// ‚úÖ DESPU√âS: Mensaje condicional
{reservation.table_ids ? (
  <Text>Mesas asignadas: {reservation.table_ids.join(', ')}</Text>
) : (
  <Text>
    Las mesas ser√°n asignadas por el restaurante antes de tu llegada.
    Recibir√°s un email de confirmaci√≥n con la asignaci√≥n final.
  </Text>
)}
```

**Archivos:**
- `src/lib/email/templates/reservation-confirmation.tsx`

---

**3.2. Crear Nueva Plantilla `table-assignment-notification.tsx`**

**Nuevo Template:**
```tsx
// src/lib/email/templates/table-assignment-notification.tsx

export const TableAssignmentNotification = ({ reservation, tables }) => (
  <EmailTemplate>
    <Heading>Mesas Asignadas</Heading>
    <Text>
      Estimado/a {reservation.customerName},
    </Text>
    <Text>
      Hemos asignado las siguientes mesas para tu reserva del {reservation.date}:
    </Text>
    <Section className="bg-gray-50 p-4 rounded">
      {tables.map(table => (
        <Row key={table.id}>
          <Column>Mesa {table.number}</Column>
          <Column>{table.capacity} personas</Column>
          <Column>{table.location}</Column>
        </Row>
      ))}
    </Section>
    <Text>
      Total de capacidad: {tables.reduce((sum, t) => sum + t.capacity, 0)} personas
    </Text>
  </EmailTemplate>
)
```

---

#### FASE 4: Validaci√≥n y Testing

**4.1. Casos de Prueba**

| # | Escenario | Resultado Esperado |
|---|-----------|-------------------|
| 1 | Cliente crea reserva de 4 personas | ‚úÖ Reserva creada sin mesas, email enviado con mensaje pendiente |
| 2 | Admin asigna mesa de 4 a reserva anterior | ‚úÖ table_ids actualizado, email enviado con asignaci√≥n |
| 3 | Admin intenta asignar mesa de 2 a reserva de 4 | ‚ùå Error de capacidad insuficiente |
| 4 | Cliente modifica reserva a 6 personas | ‚úÖ table_ids = NULL, admin debe reasignar |
| 5 | Admin dashboard muestra reservas sin mesas | ‚úÖ Badge rojo indica "Sin mesas asignadas" |

---

**4.2. Migraci√≥n de Datos Existentes**

**Opci√≥n A: Mantener mesas asignadas existentes**
```sql
-- No hacer nada, las reservas existentes mantienen sus table_ids
-- Solo las nuevas reservas tendr√°n table_ids = NULL
```

**Opci√≥n B: Resetear todas las mesas**
```sql
-- Solo para testing, NO para producci√≥n
UPDATE restaurante.reservations
SET table_ids = NULL
WHERE date >= CURRENT_DATE;
```

---

## üìà PARTE 4: ESTIMACI√ìN DE ESFUERZO

### Tiempos Estimados

| Fase | Tarea | Tiempo | Prioridad |
|------|-------|--------|-----------|
| **FASE 1** | Modificar EnhancedDateTimeAndTableStep | 2h | üî¥ Alta |
| | Modificar useReservations.createReservation | 1h | üî¥ Alta |
| | Modificar API availability | 2h | üî¥ Alta |
| | Testing frontend web | 1h | üî¥ Alta |
| **FASE 2** | Crear TableAssignmentWidget | 3h | üü° Media |
| | Integrar en dashboard | 2h | üü° Media |
| | Crear API assign-tables | 2h | üü° Media |
| | Testing admin dashboard | 1h | üü° Media |
| **FASE 3** | Modificar email confirmation | 1h | üü¢ Baja |
| | Crear email table-assignment | 2h | üü¢ Baja |
| | Testing emails | 1h | üü¢ Baja |
| **FASE 4** | Testing end-to-end | 3h | üî¥ Alta |
| | Documentaci√≥n | 1h | üü¢ Baja |
| | Migraci√≥n/rollback plan | 1h | üü° Media |

**Total Estimado**: ~23 horas (~3 d√≠as de trabajo)

---

## üöÄ PARTE 5: PLAN DE IMPLEMENTACI√ìN

### Orden Sugerido

#### D√≠a 1: Backend + API
1. ‚úÖ Modificar `/api/tables/availability` (2h)
2. ‚úÖ Crear `/api/reservations/[id]/assign-tables` (2h)
3. ‚úÖ Testing APIs con Postman (1h)
4. ‚úÖ Modificar `useReservations.createReservation` (1h)

#### D√≠a 2: Frontend Cliente + Admin
1. ‚úÖ Modificar `EnhancedDateTimeAndTableStep` (2h)
2. ‚úÖ Crear `TableAssignmentWidget` (3h)
3. ‚úÖ Integrar widget en dashboard (2h)

#### D√≠a 3: Emails + Testing
1. ‚úÖ Modificar plantillas de email (3h)
2. ‚úÖ Testing end-to-end completo (3h)
3. ‚úÖ Documentaci√≥n y capacitaci√≥n (1h)

---

## ‚ö†Ô∏è RIESGOS Y MITIGACIONES

### Riesgo 1: Reservas sin mesas asignadas
**Impacto**: Alto - Cliente llega y no tiene mesa

**Mitigaci√≥n:**
- Dashboard muestra claramente reservas sin asignar
- Email de recordatorio 24h antes SOLO si tiene mesas asignadas
- Alerta autom√°tica si reserva < 24h sin mesas

### Riesgo 2: Capacidad mal calculada
**Impacto**: Medio - Overbooking

**Mitigaci√≥n:**
- API verifica capacidad total real antes de aceptar
- Admin dashboard muestra capacidad total vs usada
- Feature flag para rollback r√°pido

### Riesgo 3: Confusi√≥n del cliente
**Impacto**: Bajo - Clientes esperan seleccionar mesas

**Mitigaci√≥n:**
- Mensaje claro en formulario de reserva
- Email de confirmaci√≥n explica proceso
- FAQ actualizado

---

## üîÑ PLAN DE ROLLBACK

### Si necesitas volver atr√°s

**1. Frontend:**
```bash
git revert <commit-hash>
npm run build
```

**2. Feature Flag:**
```env
# .env.local
NEXT_PUBLIC_ENABLE_TABLE_SELECTION=true  # Habilita selecci√≥n manual
```

**3. Base de Datos:**
```sql
-- No hay cambios de schema, solo datos
-- Reservas sin mesas pueden ser asignadas manualmente
```

---

## üìù CHECKLIST DE ACEPTACI√ìN

### Frontend Web P√∫blica
- [ ] Cliente NO ve selector de mesas
- [ ] Cliente ve mensaje "Mesas ser√°n asignadas por el restaurante"
- [ ] Reserva se crea con `table_ids = NULL`
- [ ] Email de confirmaci√≥n muestra mensaje pendiente

### Frontend Admin Dashboard
- [ ] Dashboard muestra reservas sin mesas con badge rojo
- [ ] Widget de asignaci√≥n funciona correctamente
- [ ] Validaci√≥n de capacidad impide asignaciones incorrectas
- [ ] Despu√©s de asignar, se env√≠a email al cliente

### APIs
- [ ] `/api/tables/availability` retorna aforo disponible (no lista de mesas)
- [ ] `/api/reservations` acepta `table_ids = NULL`
- [ ] `/api/reservations/[id]/assign-tables` funciona correctamente
- [ ] Validaci√≥n de capacidad en backend

### Emails
- [ ] Confirmaci√≥n muestra mensaje condicional
- [ ] Email de asignaci√≥n se env√≠a correctamente
- [ ] Recordatorio solo si tiene mesas asignadas

---

## üéØ SIGUIENTE PASO RECOMENDADO

**Opci√≥n A: Implementaci√≥n Inmediata**
1. Crear branch `feature/auto-table-assignment`
2. Implementar FASE 1 (Backend + API) primero
3. Testing incremental

**Opci√≥n B: Prototipo Primero**
1. Crear feature flag temporal
2. Implementar solo para nuevas reservas
3. Validar con staff del restaurante
4. Full rollout despu√©s de 1 semana

**Mi Recomendaci√≥n**: Opci√≥n B (prototipo controlado)

---

## ‚ùì PREGUNTAS PARA DECIDIR

1. **¬øCu√°nto tiempo antes de la reserva debe asignarse?**
   - Opci√≥n A: 24 horas antes
   - Opci√≥n B: Inmediatamente al confirmar
   - Opci√≥n C: A demanda del admin

2. **¬øQu√© pasa si el cliente modifica la reserva?**
   - Opci√≥n A: Resetea mesas (admin reasigna)
   - Opci√≥n B: Mantiene mesas si capacidad suficiente

3. **¬øQuieres asignaci√≥n autom√°tica en el futuro?**
   - S√≠ ‚Üí Preparar infraestructura ahora
   - No ‚Üí Solo asignaci√≥n manual

---

**FIN DEL INFORME**
